package BonEffect
import LinkedList
import BonusInstance
import Bonus
import ClosureTimers
import BuffObjEditing
import BonStackability
import HashMap

/**
BonEffect map to keep track of BonEffect instances (used for stackability pourposes)
*/
public HashMap<unit, LinkedList<BonEffect>> bonMap = new HashMap<unit, LinkedList<BonEffect>>()

/**
Interface for bonExpiration handling
*/
interface OnBonExpiredHandler 
    abstract function handleBonExpiration(unit bonTarget, BonEffect bonEffect)

/**
BonEffect is container of various effects that can be applied to certain unit
and automatically vanishes after duration time of BonEffect.

Uses Bonus classes.
Bonus class can be inherited by your own Bonuses to extend functionality
*/
public class BonEffect
    private LinkedList<Bonus> bonuses = new LinkedList<Bonus>()
    private real duration = 1
    private buffTuple bonBuff
    private OnBonExpiredHandler onExpiredHandler = null
    private BonStackability stackability = BonStackability.REFRESH

    /**
    Sets Bon Stackability
    */
    function setStackability(BonStackability stackability)
        this.stackability = stackability

    /**
    Returns current stackability option
    */
    function getStackability() returns BonStackability
        return this.stackability
    
    /**
    Sets BonEffect duration.
    */
    function setDuration(real duration)
        this.duration = duration

    /**
    Adds new bonus the to BonEffect.
    */
    function addBonus(Bonus bonus)
        this.bonuses.add(bonus)

    /**
    Sets buff that will be used hen BonEffect will be applied to the unit.
    */
    function setBuff(buffTuple bonBuff)
        this.bonBuff = bonBuff

    /**
    Returns true if unit has at least one stack of Bon
    */
    function isUnitUnderBon(unit u) returns boolean
        if not bonMap.has(u)
            return false
        else
            let filteredList = bonMap.get(u).filter( (BonEffect t) -> t == this )
            let result = filteredList.size() > 0
            destroy filteredList
            return result

    /**
    Returns count of stacks that specific unit has
    */
    function getStackCount(unit u) returns int
        if not bonMap.has(u)
            return 0
        else
            let filteredList = bonMap.get(u).filter( (BonEffect t) -> t == this )
            let result = filteredList.size()
            destroy filteredList
            return result

    /**
    Applys all of the Bonuses to the unit and sets up Buff for that unit.
    After Duration Time of the BonEffect all bonuses and Buff will be removed.
    */
    function applyToUnit(unit u)

        switch this.stackability
            case STACK

            case NOT_STACK

            case REFRESH

            case STACK_AND_REFRESH


        let bonusInstances = new LinkedList<BonusInstance>()
        for bonus in bonuses
            bonusInstances.add(bonus.applyBonus(u))
            u.addAbility(bonBuff.abilId)
        doAfter(this.duration) () ->
            for bonusInstance in bonusInstances
                if u != null
                    bonusInstance.removeEffect(u)
                destroy bonusInstance
            destroy bonusInstances
            u.removeAbility(bonBuff.abilId)
            //Handle OnExpiration Event
            if this.onExpiredHandler != null
                this.onExpiredHandler.handleBonExpiration(u, this)

    /**
    Sets handler to be called after bon expiries
    */
    function onExpired(OnBonExpiredHandler handler)
        //Clear previous event handler
        if this.onExpiredHandler != null
            destroy this.onExpiredHandler
        this.onExpiredHandler = handler

    ondestroy
        for bonus in this.bonuses
            destroy bonus
        destroy bonuses
        if this.onExpiredHandler != null
            destroy this.onExpiredHandler

