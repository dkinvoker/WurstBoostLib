package Status
import LinkedList
import StatusEffectInstance
import StatusEffect
import ClosureTimers
import BuffObjEditing
import StatusStackability
import HashMap
import initlater StatusInstance

/**
BonEffect map to keep track of BonEffect instances (used for stackability pourposes)
*/
public HashMap<unit, LinkedList<StatusInstance>> bonMap = new HashMap<unit, LinkedList<StatusInstance>>()

/**
Interface for bon event handling
*/
interface BonEventHandler 
    abstract function handleEvent(unit bonTarget, Status bonEffect)

/**
BonEffect is container of various effects that can be applied to certain unit
and automatically vanishes after duration time of BonEffect.

Uses Bonus classes.
Bonus class can be inherited by your own Bonuses to extend functionality
*/
public class Status
    private LinkedList<StatusEffect> bonuses = new LinkedList<StatusEffect>()
    private real duration = 1
    private buffTuple bonBuff
    private int maxStackCout = 25
    private StatusStackability stackability = StatusStackability.REAPPLY

    private BonEventHandler onStackExpiredHandler = null
    private BonEventHandler onBonExpiredHandler = null
    private BonEventHandler onBonDispelledHandler = null

    //--------- REGION: SETTERS AND GETTERS ----------------
    function getBuff() returns buffTuple
        return this.bonBuff

    function setMaxStackCout(int maxCount)
        this.maxStackCout = maxCount
    
    /**
    Gets max amount of stacks that this BonEffect can apply.
    If stackability is set to DO_NO_STACK or REAPPLY it will always return 1.
    If stackability is set to NO_OVERHEAD it will return INT_MIN cuz' this BonEffect is not meant to be stacked at any way.
    */
    function getMaxStackCout() returns int
        switch this.stackability
            case DO_NOT_STACK | REAPPLY
                return 1
            case NO_OVERHEAD
                return INT_MIN
            default
                return this.maxStackCout

    /**
    Sets Bon Stackability.
    REFREASH is default.
    Statuses with the same Buff Id are treated as one in terms of stackability.
    */
    function setStackability(StatusStackability stackability)
        this.stackability = stackability

    /**
    Returns current stackability option
    */
    function getStackability() returns StatusStackability
        return this.stackability
    
    /**
    Sets BonEffect duration.
    */
    function setDuration(real duration)
        this.duration = duration

    /**
    Sets buff that will be used hen BonEffect will be applied to the unit.
    */
    function setBuff(buffTuple bonBuff)
        this.bonBuff = bonBuff

    //------- REGION: OTHERS ----------

    /**
    Adds new bonus the to BonEffect.
    */
    function addBonus(StatusEffect bonus)
        this.bonuses.add(bonus)

    /**
    Returns true if unit has at least one stack of Bon.
    Statuses with the same Buff Id are treated as the same Bon in terms of stackability.
    */
    function isUnitUnderBon(unit u) returns boolean
        return this.getStackCount(u) > 0 ? true : false

    /**
    Returns count of stacks that specific unit has.
    Statuses with the same Buff Id are treated as the same Bon in terms of stackability.
    */
    function getStackCount(unit u) returns int
        let instancesAttachedToUnit = this.getInstancesAttachedToUnit(u)
        if instancesAttachedToUnit == null
            return 0
        else
            let result = instancesAttachedToUnit.size()
            destroy instancesAttachedToUnit
            return result

    /**
    Removes BonEffect from unit (all of its stacks). 
    It will trigger onDispelled Event but will not trigger onStackExpired nor onBonExpired.
    Returns false when unit was not under BonEffect and there was nothng to be dispelled, true otherwise.
    */
    function dispellBonEffect(unit u) returns boolean
        let bonEffectCanceleResult = this.cancelBonEffect(u)
        if bonEffectCanceleResult == true
            this.onBonDispelledHandler.handleEvent(u, this)
        return bonEffectCanceleResult

    /**
    Removes BonEffect from unit (all of its stacks). 
    It will not trigger any BonEffect events.
    Returns false when unit was not under BonEffect and there was nothng to be canceled, true otherwise.
    */
    function cancelBonEffect(unit u) returns boolean
        let bonInstances = this.getInstancesAttachedToUnit(u)
        if bonInstances == null
            return false
        for instance in bonInstances
            instance.dispell(u)
            clearBonEffectInstance(u, instance)
        u.removeAbility(this.bonBuff.abilId)
        destroy bonInstances
        return true

    //------- REGION: HELPERS -----------
    /**
    Creates BonEffectInstance based on BonusInstances list, and inserts it to bonMap under unit u key.
    */
    private function registerBonEffectInstance(unit u, LinkedList<StatusEffectInstance> bonuses) returns StatusInstance
        if not bonMap.has(u)
            bonMap.put(u, new LinkedList<StatusInstance>())
        let result = new StatusInstance(this, bonuses)
        bonMap.get(u).add(result)
        return result

    /**
    Destroys BonEffectInstance and removes it from bonMap.
    */
    private function clearBonEffectInstance(unit u, StatusInstance instance)
        let unitBons = bonMap.get(u)..remove(instance)
        destroy instance
        if unitBons.size() == 0
            bonMap.remove(u)

    /**
    Applys all of Bonuses to unit u, and returns registered BonEffectInstance
    */
    private function applyAllBonusesAndRegisterBonEffect(unit u) returns StatusInstance
        let bonusInstances = new LinkedList<StatusEffectInstance>()
        for bonus in this.bonuses
            bonusInstances.add(bonus.applyBonus(u))
        u.addAbility(this.bonBuff.abilId)
        return this.registerBonEffectInstance(u, bonusInstances)

    /**
    Gets new LinkedList that contains all instances of this BonEffect applied to unit u.
    BonEffect with the same buffId are considered the same BonEffect.
    */
    private function getInstancesAttachedToUnit(unit u) returns LinkedList<StatusInstance>
        if not bonMap.has(u)
            return null
        else
            return bonMap.get(u).filter( (StatusInstance t) -> t.getBonEffect().bonBuff.buffId == this.bonBuff.buffId )

    //------- REGION: APPLING BON --------

    /**
    Handles BonEffect appling for STACK stackability option.
    */
    private function applyToUnit_STACK(unit u)
        if this.getStackCount(u) < this.maxStackCout
            let bonInstance = this.applyAllBonusesAndRegisterBonEffect(u)

            let bonEndCallback = doAfter(this.duration) -> 
                if u != null
                    bonInstance.removeBonuses(u)
                    clearBonEffectInstance(u, bonInstance)
                    this.onStackExpiredHandler.handleEvent(u, this)
                    if not this.isUnitUnderBon(u)
                        u.removeAbility(this.bonBuff.abilId)
                        this.onBonExpiredHandler.handleEvent(u, this)

            bonInstance.bindEndOfBonCallback(bonEndCallback)

    /**
    Handles BonEffect appling for DO_NOT_STACK stackability option.
    */
    private function applyToUnit_DO_NOT_STACK(unit u)
        if not this.isUnitUnderBon(u)
            this.applyToUnit_NO_OVERHEAD(u)

    /**
    Handles BonEffect appling for REAPPLY stackability option.
    */
    private function applyToUnit_REAPPLY(unit u)
        let instancesAttachedToUnit = this.getInstancesAttachedToUnit(u)
        if instancesAttachedToUnit != null
            for bonEffectInstance in instancesAttachedToUnit
                bonEffectInstance.dispell(u)
                clearBonEffectInstance(u, bonEffectInstance)
            destroy instancesAttachedToUnit
        applyToUnit_NO_OVERHEAD(u)

    /**
    Handles BonEffect appling for STACK_AND_REAPPLY stackability option.
    */
    private function applyToUnit_STACK_AND_REAPPLY(unit u)
        int countOfStackstoApply = 1
        let instancesAttachedToUnit = this.getInstancesAttachedToUnit(u)
        if instancesAttachedToUnit != null
            countOfStackstoApply += instancesAttachedToUnit.size()
            for bonEffectInstance in instancesAttachedToUnit
                bonEffectInstance.dispell(u)
                clearBonEffectInstance(u, bonEffectInstance)
            destroy instancesAttachedToUnit
        for i = 1 to countOfStackstoApply
            this.applyToUnit_STACK(u)

    /**
    Handles BonEffect appling for NO_OVERHEAD stackability option.
    */
    private function applyToUnit_NO_OVERHEAD(unit u)
        let bonInstance = this.applyAllBonusesAndRegisterBonEffect(u)

        let bonEndCallback = doAfter(this.duration) -> 
            if u != null
                bonInstance.removeBonuses(u)
                clearBonEffectInstance(u, bonInstance)
                u.removeAbility(this.bonBuff.abilId)
                this.onStackExpiredHandler.handleEvent(u, this)
                this.onBonExpiredHandler.handleEvent(u, this)
                    
        bonInstance.bindEndOfBonCallback(bonEndCallback)
           

    /**
    Applys all of the Bonuses to the unit and sets up Buff for that unit.
    After Duration Time of the BonEffect all bonuses and Buff will be removed.
    */
    function applyToUnit(unit u)
        switch this.stackability
            case STACK
                applyToUnit_STACK(u)
            case DO_NOT_STACK
                applyToUnit_DO_NOT_STACK(u)
            case REAPPLY
                applyToUnit_REAPPLY(u)
            case STACK_AND_REAPPLY
                applyToUnit_STACK_AND_REAPPLY(u)
            case NO_OVERHEAD
                applyToUnit_NO_OVERHEAD(u)

    //--------- REGION: EVENTS -----------

    /**
    Sets handler to be called after each stack expiries.
    */
    function onStackExpired(BonEventHandler handler)
        //Clear previous event handler
        if this.onStackExpiredHandler != null
            destroy this.onStackExpiredHandler
        this.onStackExpiredHandler = handler

    /**
    Sets handler to be called after all stacks expiries.
    */
    function onBonExpired(BonEventHandler handler)
        //Clear previous event handler
        if this.onBonExpiredHandler != null
            destroy this.onBonExpiredHandler
        this.onBonExpiredHandler = handler

    /**
    Sets handler to be called after bon is dispelled.
    */
    function onBonDispelled(BonEventHandler handler)
        //Clear previous event handler
        if this.onBonDispelledHandler != null
            destroy this.onBonDispelledHandler
        this.onBonDispelledHandler = handler

    //------ REGION: DESTRUCTOR ------        

    ondestroy
        for bonus in this.bonuses
            destroy bonus
        destroy bonuses
        if this.onStackExpiredHandler != null
            destroy this.onStackExpiredHandler
        if this.onBonExpiredHandler != null
            destroy onBonExpiredHandler

